# String Basic Problems

### 1. Longest Common Substring
[Leetcode](https://leetcode.com/problems/longest-common-prefix/description/)
```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs == null || strs.length == 0) return "";
        
        String prefix = strs[0];

        for(int i=1; i<strs.length; i++) {
            while(strs[i].indexOf(prefix)!=0) {
                prefix = prefix.substring(0, prefix.length() - 1);

                if(prefix.isEmpty()) return ""; 
            }
        }
        return prefix;
    }
}
```
---
### 2. FizzBuzz
[Leetcode](https://leetcode.com/problems/fizz-buzz/)
```java
class Solution {
    public List<String> fizzBuzz(int n) {
        List<String> res = new ArrayList<>();
        for(int i=1; i<=n; i++) {
            if(i%3==0 && i%5==0) {
                res.add("FizzBuzz");
            } else if(i%3==0) {
                res.add("Fizz");
            } else if(i%5==0) {
                res.add("Buzz");
            } else {
                res.add(String.valueOf(i));
            }
        }
        return res;
    }
}
```
---
### 3. Valid Anagram
[Leetcode](https://leetcode.com/problems/valid-anagram/description/)

**Brute**
```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if(s.length() != t.length()) return false;
        char[] sortedS = s.toCharArray();
        char[] sortedT = t.toCharArray();
        Arrays.sort(sortedS);
        Arrays.sort(sortedT); 
        
        return Arrays.equals(sortedS, sortedT);
    }
}
```

**Optimal**
```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if(s.length() != t.length()) return false;
        int[] count = new int[26];

        for(int i=0; i<s.length(); i++) {
            count[s.charAt(i)-'a']++;
            count[t.charAt(i)-'a']--;
        }

        for(int c: count) {
            if(c!=0) return false;
        }
        return true;
    }
}
```
---
### 4. Group Anagrams
[Leetcode](https://leetcode.com/problems/group-anagrams/description/)

**Brute**
```java
class Solution {
    public boolean isAnagram(String s1, String s2) {
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();

        Arrays.sort(arr1);
        Arrays.sort(arr2);

        return Arrays.equals(arr1, arr2);
    }

    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> result = new ArrayList();
        boolean[] visited = new boolean[strs.length];

        for(int i=0; i<strs.length; i++) {
            if(visited[i]) continue;

            List<String> group = new ArrayList<>();
            group.add(strs[i]);
            visited[i] = true;

            for(int j=i+1; j<strs.length; j++) {
                if(!visited[j] && isAnagram(strs[i], strs[j])) {
                    group.add(strs[j]);
                    visited[j] = true;
                }
            }
            result.add(group);
        }
        return result;
    }
}
```
- **‚è± Time Complexity:** O(N^2 * K log K)
- **üíæ Space:** O(N*K)

**Better**
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();

        for(String s: strs) {
            char[] chars = s.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);

            map.computeIfAbsent(key, k->new ArrayList<>()).add(s);
        }

        return new ArrayList<>(map.values());
    }
}
```
- **‚è± Time Complexity:** O(N * K log K)
- **üíæ Space:** O(N*K)
---
### 5. Find Resultant Array After Removing Anagrams
[Leetcode](https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/description/)

```java
class Solution {
    public List<String> removeAnagrams(String[] words) {
        List<String> result = new ArrayList<>();
        String prevKey = ""; 

        for (String word : words) {
            char[] chars = word.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);
            
            if (!key.equals(prevKey)) {
                result.add(word);
                prevKey = key;
            }
        }
        return result;
    }
}
```
---
### 6. Reverse String

[Leetcode-344](https://leetcode.com/problems/reverse-string/description/)

**Two Pointers Approach**
```java
class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length-1;
        while(left<right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
}
```
- **‚è± Time Complexity:** O(N)
- **üíæ Space:** O(1)

**Recursive Solution**
```java
class Solution {
    public void reverse(char[] s, int left, int right) {
        if(left>=right) return;
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        reverse(s, ++left, --right);
    }

    public void reverseString(char[] s) {
        reverse(s, 0, s.length-1);
    }
}
```
- **‚è± Time Complexity:** O(N)
- **üíæ Space:** O(N)
---
### 7. Reverse Vowels of a String

[Leetcode-345](https://leetcode.com/problems/reverse-vowels-of-a-string/description/)

```java
class Solution {
    public String reverseVowels(String s) {
        char[] str = s.toCharArray();
        int left = 0;
        int right = str.length-1;
        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));

        while(left<right) {
            while(left<right && !vowels.contains(str[left])) {
                left++;
            }
            while(left<right && !vowels.contains(str[right])) {
                right--;
            }
            if(left<right) {
                char temp = str[left];
                str[left] = str[right];
                str[right] = temp;
                left++;
                right--;
            }
        }
        return new String(str);
    }
}
```
- **‚è± Time Complexity:** O(N)
- **üíæ Space:** O(1)
---
### 8. Reverse String II

[Leetcode-541](https://leetcode.com/problems/reverse-string-ii/description/)

```java
class Solution {
    public void reverse(char[] arr, int start, int end) {
        while(start<end) {
            char temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }

    public String reverseStr(String s, int k) {
        char[] arr = s.toCharArray();
        
        for(int i=0; i<arr.length; i+=(2*k)) {
            int end = Math.min(i + k - 1, arr.length - 1);
            reverse(arr, i, end);
        }
        return new String(arr);
    }
}
```
- **‚è± Time Complexity:** O(N)
- **üíæ Space:** O(n) (Because of char array)
---
### 9. Faulty Keyboard

[Leetcode-2810](https://leetcode.com/problems/faulty-keyboard/)

**Brute**
```java
class Solution {
    public String finalString(String s) {
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (c == 'i') sb.reverse();  // O(current length) each time
            else sb.append(c);
        }
        return sb.toString();
    }
}
```
- **‚è± Time Complexity:** O(N^2)
- **üíæ Space:** O(n)

**Optimal**
```java
class Solution {
    public String finalString(String s) {
        Deque<Character> dq = new ArrayDeque<>();
        boolean inverted = false;

        for(char c: s.toCharArray()) {
            if(c=='i') {
                inverted = !inverted;
            } else if(inverted) {
                dq.offerFirst(c);
            } else {
                dq.offerLast(c);
            }
        }

        StringBuilder sb = new StringBuilder();
        if(inverted) {
            while(!dq.isEmpty()) {
                sb.append(dq.pollLast());
            }
        } else {
            while(!dq.isEmpty()) {
                sb.append(dq.pollFirst());
            }
        }
        return sb.toString();
    }
}
```
- **‚è± Time Complexity:** O(n)
- **üíæ Space:** O(n)
---
### 10. Reverse Only Letters

[Leetcode-917](https://leetcode.com/problems/reverse-only-letters/description/)

```java
class Solution {
    public String reverseOnlyLetters(String s) {
        char[] arr = s.toCharArray();
        int low = 0;
        int high = arr.length-1;
        while(low<high) {
            while(low<high && !Character.isLetter(arr[low])) low++;
            while(low<high && !Character.isLetter(arr[high])) high--;
            if(low<high) {
                char temp = arr[low];
                arr[low] = arr[high];
                arr[high] = temp;
                low++;
                high--;
            }
        }
        return new String(arr);
    }
}
```
- **‚è± Time Complexity:** O(n)
- **üíæ Space:** O(n)
---
### 11. Find the Original Typed String I

[Leetcode-3330](https://leetcode.com/problems/find-the-original-typed-string-i/description/)

**Intution:**
- Start with 1 possible string: the string itself if no long key press occurred.
- Each consecutive duplicated character (i.e., where word[i] == word[i - 1]) represents an opportunity ‚Äî Alice may have held that key too long just for that one instance.
- So, every such adjacent pair adds +1 to the count of possible originals.
- The final answer is simply:
1 (base case) + the number of adjacent equal character pairs.

```java
class Solution {
    public int possibleStringCount(String word) {
        int ans = 1;
        for(int i=1; i<word.length(); i++) {
            if(word.charAt(i)==word.charAt(i-1)) {
                ans++;
            }
        }
        return ans;
    }
}
```
- **‚è± Time Complexity:** O(n)
- **üíæ Space:** O(1)
---
### 12. Faulty Keyboard

[Leetcode-500](https://leetcode.com/problems/keyboard-row/)

**Brute**
```java
class Solution {
    public boolean checkRow(char[] arr, String row) {
        int i=1;
        while(i<arr.length) {
            if(row.indexOf(arr[i])==-1) {
                return false;
            }
            i++;
        }
        return true;
    }
    public String[] findWords(String[] words) {
        String row1 = "qwertyuiop";
        String row2 = "asdfghjkl";
        String row3 = "zxcvbnm";
        List<String> ans = new ArrayList<>();
        for(String word: words) {
            String lower = word.toLowerCase();
            if(row1.indexOf(lower.charAt(0)) != -1 && checkRow(lower.toCharArray(), row1)) {
                ans.add(word);
            } else if(row2.indexOf(lower.charAt(0)) !=-1 && checkRow(lower.toCharArray(), row2)) {
                ans.add(word);
            } else if(row3.indexOf(lower.charAt(0)) != -1 && checkRow(lower.toCharArray(), row3)) {
                ans.add(word);
            }
        }
        return ans.toArray(new String[0]);
    }
}
```
- **‚è± Time Complexity:** O(10*n)     _(Closer to n^2 in worst case)_
- **üíæ Space:** O(1)

**Optimal**
```java
class Solution {

    public String[] findWords(String[] words) {
        String row1 = "qwertyuiop";
        String row2 = "asdfghjkl";
        String row3 = "zxcvbnm";
        List<String> ans = new ArrayList<>();

        int[] rows = new int[26];
        for(char c: row1.toCharArray()) rows[c-'a'] = 1;
        for(char c: row2.toCharArray()) rows[c-'a'] = 2;
        for(char c: row3.toCharArray()) rows[c-'a'] = 3;

        for(String word: words) {
            String lower = word.toLowerCase();
            int row = rows[lower.charAt(0)-'a'];
            boolean valid = true;
            for(char ch: lower.toCharArray()) {
                if(rows[ch-'a']!=row) {
                    valid = false;
                    break;
                }
            }
            if(valid) ans.add(word);
        }
        return ans.toArray(new String[0]);
    }
}
```
- **‚è± Time Complexity:** O(n)    
- **üíæ Space:** O(1)